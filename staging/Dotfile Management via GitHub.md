# **The Architecture of the Minimalist Home Directory: A Comprehensive Guide to XDG Compliance, Git-Based Configuration, and Environment Management**

## **Executive Summary**

The modern developer workstation is not merely a collection of files but a complex, stateful distributed system that happens to reside on a single disk. As software ecosystems have expanded, the user’s home directory (\~) has traditionally devolved into a chaotic dumping ground for configuration files, application state, cache databases, and ephemeral logs. This entropy—often referred to as "dotfile sprawl"—undermines system reproducibility, complicates backup strategies, and increases the cognitive load required to manage a personal computing environment.

This report presents a definitive, exhaustively detailed architecture for restructuring the personal home directory into a minimal, semantic, and version-controlled environment. By leveraging the **XDG Base Directory Specification** to decouple configuration from state, employing **Bare Git Repositories** for seamless version control, and utilizing advanced environment variable injection to coerce non-compliant applications (such as Visual Studio Code and Anthropic’s Claude) into compliance, a user can achieve a "Minimal Root" state. In this architecture, the root of the home directory contains only user-defined semantic subdirectories (e.g., \~/src, \~/data), while all configuration resides in a managed, invisible namespace.

The following analysis synthesizes technical standards, operating system internals (Linux, macOS, Windows), and modern developer tooling into a cohesive strategy for maintaining a portable, secure, and clean home directory via GitHub.

## ---

**1\. The Theoretical Framework of Directory Hygiene**

The layout of a file system is the user’s primary interface with their data. In Unix-like operating systems, the home directory was originally conceived as a private space for user files. However, the convention of storing configuration files as "dotfiles" (files prefixed with a period, e.g., .bashrc) in the root of the home directory has proven to be an architectural liability in the modern era.

### **1.1 The Problem of Root Entropy**

In a default installation, a developer’s home directory conflates three distinct classes of data, each requiring different management lifecycles:

1. **Configuration (Infrastructure as Code):** These are text files that define how software should behave. They are manually authored or tweaked by the user, are small in size, and are critical to reproduce the working environment. Examples include .vimrc, .gitconfig, and shell profiles. These files demand version control.  
2. **State and Cache (Ephemeral Data):** These are files generated by applications to speed up performance or maintain session continuity. They are often large, binary, and regenerable. Examples include node\_modules caches, browser history, compilation artifacts (.o files), and log files. Backing these up is usually a waste of storage and bandwidth.  
3. **User Data (Persistent Assets):** This is the content the user actually creates and cares about—source code, documents, keys, and media. These require robust backup strategies (RAID, cloud, offsite) but often typically do not belong in a public configuration repository.

When these three categories are mixed in a flat hierarchy at \~, distinct problems emerge. A simple backup command (tar \-czf backup.tar.gz \~) inadvertently captures gigabytes of cache. A git status check in the home directory is overwhelmed by noise. Migrating to a new machine becomes an archaeological excavation to determine which dotfiles are essential settings and which are merely abandoned state from uninstalled software.

### **1.2 The Philosophy of the Minimal Root**

The "Minimal Root" philosophy advocates for a home directory that acts strictly as a semantic entry point for the user. It asserts that:

* **The Root is for the User:** Only directories explicitly created by the user for categorization (e.g., src, docs, bin) should be visible in \~.  
* **Configuration is Hidden but Organized:** All configuration should reside in a single, dedicated subdirectory (standardized as .config), mirroring the /etc directory structure of the system root.  
* **State is Segregated:** All cache and ephemeral data should reside in dedicated locations (.cache, .local/share), mirroring /var and /tmp.

This separation allows the home directory to be treated as a Git repository where the .gitignore logic is simple and robust, and where the "working tree" remains clean.

## ---

**2\. The XDG Base Directory Standard**

The primary mechanism for achieving directory hygiene is the **XDG Base Directory Specification**, maintained by freedesktop.org. While originally designed for Linux desktop environments (GNOME, KDE), it has been widely adopted by command-line tools and is the gold standard for cross-platform directory management.1

### **2.1 The Core Variables**

The specification defines a set of environment variables that determine where files should be stored. By explicitly setting these variables early in the user’s login session (a process detailed in Section 6), the user takes control of the layout.

| Variable | Default Path | Definition and Purpose | Backup Policy |
| :---- | :---- | :---- | :---- |
| **XDG\_CONFIG\_HOME** | $HOME/.config | Stores configuration files. This directory corresponds to the user-specific equivalent of /etc. Files here should be read-only for the application but writable by the user. | **Critical:** Must be version-controlled via GitHub. |
| **XDG\_DATA\_HOME** | $HOME/.local/share | Stores user-specific data files that are not configuration. This includes keyrings, desktop entries, fonts, and skins. It is the user analogue to /usr/share. | **Selective:** Back up distinct subdirectories (e.g., fonts, gnupg). |
| **XDG\_CACHE\_HOME** | $HOME/.cache | Stores non-essential data files. Examples include thumbnails, web browser caches, and package manager buffers. Applications must handle the absence of these files gracefully. | **None:** Exclude from backups. Safe to rm \-rf. |
| **XDG\_STATE\_HOME** | $HOME/.local/state | Stores state data that should persist between restarts (like logs, history files, last-opened file lists) but is not configuration. | **None:** Generally excluded from config backups. |
| **XDG\_RUNTIME\_DIR** | /run/user/$UID | A directory for user-specific non-essential runtime files (sockets, named pipes). This is usually managed by the OS (systemd) and cleared on reboot. | **None:** Volatile system area. |

**Analytical Insight:** The introduction of XDG\_STATE\_HOME is a relatively recent refinement.1 Historically, applications dumped logs and history into XDG\_DATA\_HOME or XDG\_CACHE\_HOME. Separating "State" (history files which are valuable but not configuration) allows for more granular backup policies. For instance, a user might want to back up their shell history (State) but not their browser cache (Cache), even though neither is strictly "Configuration."

### **2.2 The Compliance Landscape**

Adoption of XDG is high among modern CLI tools (Rust and Go ecosystems are particularly compliant) but inconsistent among legacy Unix utilities and commercial GUI applications.

* **Compliant:** Neovim, Git, Helix, Yarn, Fish Shell.  
* **Partially Compliant:** Zsh (requires ZDOTDIR), GnuPG (requires GNUPGHOME), Bash (requires sourcing workarounds).  
* **Non-Compliant:** OpenSSH (\~/.ssh), AWS CLI (defaults to \~/.aws), Kubernetes (\~/.kube), and many macOS-native applications which prefer the Apple \~/Library standard.

Managing a minimal root requires a strategy of "Shims"—using environment variables, aliases, and symlinks to coerce non-compliant applications into the XDG structure. This is detailed in Section 7\.

## ---

**3\. Architecture of Version Control: The Dotfiles Repository**

Central to managing the home directory is the choice of Version Control System (VCS) architecture. The objective is to track the contents of XDG\_CONFIG\_HOME and select files in the root (like .zshenv) without tracking the petabytes of personal data that may accumulate in \~/Downloads or \~/src.

### **3.1 The Bare Git Repository Strategy**

The **Bare Git Repository** is the most elegant solution for users prioritizing a minimal toolchain. Unlike standard git repositories, which place a .git folder inside the working directory, a bare repository stores the git metadata in a separate folder (e.g., \~/.cfg) and treats the home directory (\~) as its working tree.2

#### **Mechanism of Action**

In a standard git setup, git init creates .git/. If you run this in your home directory, every subdirectory becomes part of the repo search path, significantly degrading system performance and interfering with other git repositories located in \~/src.

The Bare Repo approach decouples the database from the files:

1. **Repository Storage:** A directory (commonly \~/.cfg or \~/.dotfiles) holds the object database.  
2. **Working Tree:** The $HOME directory is defined as the checkout location.  
3. **Command Alias:** A shell alias wraps the git command to permanently reference these locations.

#### **Implementation Guide**

To bootstrap this architecture:

Bash

\# 1\. Initialize the bare repository  
git init \--bare $HOME/.cfg

\# 2\. Define the alias (temporary for the current session)  
alias config='/usr/bin/git \--git-dir=$HOME/.cfg/ \--work-tree=$HOME'

\# 3\. Hide untracked files  
config config \--local status.showUntrackedFiles no

**Insight:** The command status.showUntrackedFiles no is the linchpin of this strategy. Without it, git status would list thousands of files (every photo, download, and code file) as "untracked." With this setting enabled, the repository ignores everything in the home directory *unless it is explicitly added* via config add \<file\>. This creates an "opt-in" version control system, perfect for a cluttered root.4

### **3.2 Comparative Analysis: Bare Repo vs. Stow vs. Chezmoi**

While the Bare Repo is powerful, other tools offer distinct advantages depending on the user's requirements for cross-platform synchronization and templating.

| Feature | Bare Git Repo | GNU Stow | Chezmoi |
| :---- | :---- | :---- | :---- |
| **Mechanism** | Git working tree at $HOME | Symlinks from \~/dotfiles to \~ | Generates files from templates |
| **Root Cleanliness** | Excellent (No visible repo folder needed) | Good (Requires \~/dotfiles folder) | Excellent (Source hidden in \~/.local/share) |
| **Dependencies** | Git only (universal) | Perl/Stow | Go binary (Chezmoi) |
| **Cross-Platform** | Requires manual branching or shell logic | Difficult (Windows/macOS paths differ) | **Superior** (Native templating) |
| **Secrets** | Requires git-crypt or sops | Difficult to integrate | Native password manager integration |
| **Complexity** | High initial concept, low maintenance | Low | High setup, powerful automation |

**Assessment:**

* **GNU Stow** operates by creating a symlink farm. If you have a file \~/dotfiles/vim/.vimrc, running stow vim symlinks it to \~/.vimrc. While simple, it clutters the home directory with the \~/dotfiles source folder and relies on symlinks, which can sometimes be overwritten by aggressive software updates.2  
* **Chezmoi** is an enterprise-grade solution. It does not symlink; it copies files or generates them from templates. This allows a single source file to generate different configs for macOS (using \~/Library) and Linux (using \~/.config). It supports password managers (1Password, Bitwarden) natively, injecting secrets during file generation. For users managing a fleet of heterogeneous machines (e.g., a Windows Workstation, a MacBook Pro, and an Arch Linux server), **Chezmoi** is the superior choice despite the added complexity.5

For the specific request of a "minimal root" managed via GitHub, the **Bare Repository** offers the most direct "native" Git experience without introducing an intermediate build step or binary dependency, assuming the user is comfortable with git internals.

## ---

**4\. The Shell Environment: The Bootstrapping Layer**

The shell (Zsh or Bash) is the entry point for the user session. It is responsible for initializing the XDG environment variables that subsequent applications will rely on. Therefore, cleaning the shell configuration is the first step in cleaning the root.

### **4.1 The Z Shell (Zsh) and ZDOTDIR**

Zsh is the default shell on macOS and a favorite among developers. By default, it looks for its configuration files (.zshrc, .zprofile, .zlogin, .zshenv) in the user's home directory. This contributes four files to root clutter.

Fortunately, Zsh supports the ZDOTDIR environment variable. If this variable is set, Zsh will look for its configuration files in that directory instead of $HOME.7

#### **The Immutable .zshenv**

There is one catch: Zsh must know *where* ZDOTDIR is before it can load config from it. The only file Zsh reads from $HOME unconditionally is \~/.zshenv. This file acts as the bootstrapper.

**The Minimal \~/.zshenv Strategy:**

We place a single file in the root, \~/.zshenv, containing the XDG definitions and the redirection logic:

Bash

\# \~/.zshenv  
\# 1\. Define XDG Base Directory variables  
export XDG\_CONFIG\_HOME="${XDG\_CONFIG\_HOME:-$HOME/.config}"  
export XDG\_DATA\_HOME="${XDG\_DATA\_HOME:-$HOME/.local/share}"  
export XDG\_CACHE\_HOME="${XDG\_CACHE\_HOME:-$HOME/.cache}"  
export XDG\_STATE\_HOME="${XDG\_STATE\_HOME:-$HOME/.local/state}"

\# 2\. Redirect Zsh configuration  
export ZDOTDIR="$XDG\_CONFIG\_HOME/zsh"

\# 3\. Source the 'real' zshenv if it exists in the new location  
if\]; then  
    source "$ZDOTDIR/.zshenv"  
fi

**Result:**

* The root directory contains only .zshenv.  
* The .zshrc, .zprofile, .zlogin, and .zhistory files are moved to \~/.config/zsh/.  
* Note: .zsh\_history often needs explicit reconfiguration inside .zshrc:  
  HISTFILE="$XDG\_STATE\_HOME/zsh/history"

### **4.2 Bash and Legacy Compatibility**

Bash is less flexible than Zsh regarding directory relocation. It hardcodes lookups for \~/.bashrc and \~/.bash\_profile. To maintain a minimal root while supporting Bash (often used by scripts even if Zsh is the interactive shell):

1. **Move Configs:** Place the actual configuration in \~/.config/bash/.  
2. **Source Files:** Create "shim" files in root that do nothing but source the XDG location.  
   Bash  
   \# \~/.bashrc  
   \[ \-f "$HOME/.config/bash/bashrc" \] &&. "$HOME/.config/bash/bashrc"

3. **Hide Files:** On macOS and Windows, files starting with a dot are hidden by default. On Linux, they are hidden from ls but visible in ls \-a. This is an unavoidable compromise for Bash compatibility.

## ---

**5\. Application Configuration Strategies**

The core request involves managing configurations for specific tools: VS Code, Claude, and general folders. These applications often defy XDG standards, requiring specific intervention strategies.

### **5.1 Visual Studio Code (VS Code)**

VS Code presents a significant challenge to the minimal root philosophy because it is an Electron app with both a GUI and a CLI interface, and it maintains strict separation between "User Data" and "Extensions."

#### **The Extensions Directory Problem**

By default, VS Code creates a \~/.vscode directory in the root to store extensions (\~/.vscode/extensions). This directory can grow to gigabytes in size.

**Solution 1: CLI Flags (Transient)**

You can launch VS Code with the \--extensions-dir flag:

Bash

code \--extensions-dir "$XDG\_DATA\_HOME/vscode/extensions"

However, this only works when launching from the terminal. If you open VS Code via the Dock, Spotlight, or Start Menu, it will revert to \~/.vscode.9

**Solution 2: Environment Variables (Inconsistent)** Some documentation suggests VSCODE\_EXTENSIONS as an environment variable, but this is primarily for the portable version or specific server implementations. It is not reliably respected by the standard desktop installation on all OSs.11

**Solution 3: The Symlink (Robust)**

The most reliable method to clean the root is to move the directory and leave a pointer.

1. Create the destination: mkdir \-p \~/.local/share/vscode/extensions  
2. Move existing extensions: mv \~/.vscode/extensions/\* \~/.local/share/vscode/extensions/  
3. Remove the root folder: rm \-rf \~/.vscode  
4. Link it back: ln \-s \~/.local/share/vscode \~/.vscode  
   *Critique:* This technically leaves a file (the symlink) in root. However, it prevents the *creation* of a physical directory.

#### **Configuration Sync: settings.json**

VS Code stores user settings in platform-specific paths:

* **macOS:** \~/Library/Application Support/Code/User/settings.json  
* **Linux:** \~/.config/Code/User/settings.json  
* **Windows:** %APPDATA%\\Code\\User\\settings.json

**Management Strategy:**

Do not try to move the entire User folder, as it contains dynamic databases. Instead, manage settings.json and keybindings.json in your dotfiles repo (e.g., inside \~/.config/vscode/) and symlink them to the OS-specific path.

Bash

\# Example setup script line for macOS  
ln \-sf "$XDG\_CONFIG\_HOME/vscode/settings.json" \\  
       "$HOME/Library/Application Support/Code/User/settings.json"

This ensures your config is versioned in your clean structure, while VS Code finds it where it expects.12

### **5.2 Anthropic Claude Configuration**

Configuration for Claude is bifurcated between the **Claude Desktop Application** and the **Claude Code CLI**.

#### **Claude Desktop (Electron App)**

The desktop application stores its configuration, including definitions for **MCP (Model Context Protocol)** servers, in a JSON file.

* **Location (macOS):** \~/Library/Application Support/Claude/claude\_desktop\_config.json  
* **Location (Windows):** %APPDATA%\\Claude\\claude\_desktop\_config.json  
* **Content:** API keys for MCP servers, command arguments, and environment definitions.13

**Strategy:** Similar to VS Code, create a version-controlled file \~/.config/claude/claude\_desktop\_config.json and symlink it to the system location. This allows you to track your MCP server setup in Git. *Warning:* Ensure this file does not contain raw API keys if your repo is public. Use environment variable expansion if supported by the parser, or use a private repo.

#### **Claude Code (CLI Tool)**

The CLI tool (formerly managing config in \~/.claude) has been evolving.

* **Legacy:** Stored session data and configs in \~/.claude.  
* **Current State (v1.0.29+):** Recent updates indicate a migration toward XDG compliance, moving config to \~/.config/claude.14  
* **Project Config:** Claude Code also looks for CLAUDE.md files in the current working directory or \~/.claude/CLAUDE.md for user-level instructions.15

**Cleanup:**

To ensure a minimal root:

1. Check for the existence of \~/.claude.  
2. If it exists, verify if your installed version supports XDG\_CONFIG\_HOME.  
3. If not, and you cannot force it via env vars, you may need to hide it via .gitignore and accept it as a temporary violation until the tool matures.  
4. **Important:** CLAUDE.md files are intended to be checked into project repositories (like .gitignore or README.md). They define project-specific context for the AI and should be treated as documentation, not user dotfiles.

### **5.3 Cloud Infrastructure Tools (AWS, Kubernetes)**

Cloud CLIs are notorious for cluttering the home directory (.aws, .kube, .azure). However, they are also designed for automation, meaning they almost always support environment variable overrides.

#### **Kubernetes (.kube)**

* **Default:** \~/.kube/config  
* **XDG Fix:**  
  Bash  
  export KUBECONFIG="$XDG\_CONFIG\_HOME/kube/config"

  *Note:* You must manually create the directory \~/.config/kube. Tools like kubectl, helm, and k9s will respect this variable.17

#### **AWS CLI (.aws)**

* **Default:** \~/.aws/config and \~/.aws/credentials  
* **XDG Fix:**  
  Bash  
  export AWS\_CONFIG\_FILE="$XDG\_CONFIG\_HOME/aws/config"  
  export AWS\_SHARED\_CREDENTIALS\_FILE="$XDG\_CONFIG\_HOME/aws/credentials"

  *Caveat:* While the AWS CLI respects these, third-party SDKs (e.g., older Python Boto3 scripts or Terraform providers) might fallback to looking for \~/.aws if the environment variables are not correctly propagated to their process tree. For robust compatibility, a symlink (ln \-s \~/.config/aws \~/.aws) is often safer than pure env vars.19

## ---

**6\. Secrets Management and Security**

When moving dotfiles to GitHub, the risk of leaking secrets (SSH private keys, API tokens) is paramount. A "minimal root" often implies automating the setup of a new machine, which requires these secrets to be present.

### **6.1 Repository Privacy**

The simplest security layer is to use a **Private GitHub Repository**. GitHub Free allows unlimited private repositories. This obscures your configs from the public internet but does not encrypt them at rest on GitHub’s servers. If your GitHub account is compromised, your secrets are exposed.

### **6.2 Encryption at Rest: git-crypt vs. SOPS**

To safely store secrets in a git repo, encryption is required.

**Option A: git-crypt**

* **Mechanism:** Transparently encrypts files on git push and decrypts on git pull using a symmetric key or GPG key.  
* **Workflow:** You add a .gitattributes file:  
  secrets/\* filter=git-crypt diff=git-crypt  
  .ssh/id\_rsa filter=git-crypt diff=git-crypt  
* **Pros:** Seamless workflow. Files look like plain text locally.  
* **Cons:** Binary diffs on GitHub (you can't see changes in the UI). Difficult to rotate keys.21

**Option B: SOPS (Secrets OPerationS)**

* **Mechanism:** Mozilla’s tool that encrypts *values* inside JSON/YAML files but leaves keys readable.  
* **Pros:** Better integration with cloud KMS (Key Management Services) and allows diffing of structure.  
* **Cons:** Higher setup complexity. Requires the sops binary on every machine.22

**Recommendation:** For a personal home directory, **git-crypt** is generally sufficient and offers the lowest friction.

### **6.3 Runtime Injection: 1Password/Bitwarden CLI**

The most secure approach is **not to store secrets in Git at all**, even encrypted. Instead, store them in a dedicated password manager and inject them at runtime.

* **Integration with Direnv:**  
  Use direnv to load secrets into the environment only when needed.  
  Bash  
  \# \~/.config/aws/.envrc  
  export AWS\_ACCESS\_KEY\_ID=$(op read op://Private/AWS/access-key)  
  export AWS\_SECRET\_ACCESS\_KEY=$(op read op://Private/AWS/secret-key)

  This keeps the file system clean of plain-text secrets entirely.

## ---

**7\. Cross-Platform Compatibility: macOS vs. Linux vs. Windows**

A robust dotfiles setup often needs to span multiple operating systems. This introduces path inconsistencies.

### **7.1 The macOS \~/Library Challenge**

macOS enforces the \~/Library structure for GUI apps. While CLI tools on macOS are increasingly XDG-compliant, system apps are not.

* **Solution:** Use the Git repository as the source of truth (using XDG paths like \~/.config/app) and use a **setup script** to symlink these to the macOS locations (\~/Library/...).  
* **Script Logic:**  
  Bash  
  if\]; then  
      ln \-sf "$XDG\_CONFIG\_HOME/karabiner" "$HOME/.config/karabiner"  
      ln \-sf "$XDG\_CONFIG\_HOME/rectangle" "$HOME/Library/Application Support/Rectangle"  
  fi

### **7.2 Windows and WSL**

* **WSL (Windows Subsystem for Linux):** This is essentially a Linux instance. It allows you to share the Windows file system, but it is best managed as an independent Linux node using standard XDG paths.  
* **Native Windows:** PowerShell and Windows Terminal use %APPDATA%.  
  * If managing native Windows configs via the same repo, usage of **Chezmoi** is strongly recommended over the Bare Repo method, as Chezmoi handles line-ending conversion (CRLF vs LF) and path separators (\\ vs /) natively.6

## ---

**8\. Data Organization: The src and tmp Directories**

With configuration hidden, the root is reserved for user data.

### **8.1 The Source Code Directory (\~/src)**

Avoid ambiguous folder names like Projects or Code. Adopt the Unix convention \~/src (or \~/git).

* **Structure:**  
  Adopting a hierarchical structure prevents a flat list of 50 repositories. The host/org/repo pattern (popularized by Go) is highly effective:  
  \~/src/  
  ├── github.com/  
  │   ├── my-username/  
  │   │   ├── dotfiles/  
  │   │   └── project-alpha/  
  │   └── anthropic/  
  │       └── claude-sdk/  
  └── gitlab.com/  
      └── work-org/  
          └── backend-service/

  This makes navigation predictive (cd \~/src/github.com/my-username/project).

### **8.2 Managing "Desktop" and "Downloads"**

* **Linux:** You can relocate these using \~/.config/user-dirs.dirs.  
  Bash  
  XDG\_DESKTOP\_DIR="$HOME/.local/share/Desktop"  
  XDG\_DOWNLOAD\_DIR="$HOME/tmp/downloads"

  This physically moves the folders out of root.23  
* **macOS:** These folders (\~/Desktop, \~/Downloads) are protected by SIP (System Integrity Protection) and relied upon by the OS.  
  * **Mitigation:** You cannot delete them. You can, however, hide them from the Finder or terminal listings using chflags hidden \~/Desktop. *Warning:* This may confuse you when looking for files saved to Desktop. The pragmatic approach on macOS is to accept Desktop, Documents, Downloads, Library, Movies, Music, Pictures, and Public as the immutable "base system" and keep everything else minimal.

## ---

**9\. Handling Large Files: Git LFS**

A home directory often contains binary assets: fonts, wallpapers, icon sets, or small binaries.

### **9.1 The Limits of Git**

Git is designed for text. Storing large binaries bloats the .git folder (or .cfg in our bare repo case) because every version of every binary is stored in history.

### **9.2 Git Large File Storage (LFS)**

Git LFS replaces large files with text pointers in the main repo, storing the actual blobs on a separate server.

* **GitHub Constraints:** GitHub Free tier limits LFS storage to **2 GB** and, crucially, **bandwidth to 1 GB/month**.24  
* **Implication:** If you store 500MB of wallpapers and clone your repo twice in a month, you have exhausted your bandwidth.

### **9.3 Recommended Strategy**

For a personal dotfiles repo:

1. **Avoid LFS for "Nice to Haves":** Do not track heavy wallpapers or fonts in Git LFS if you frequently clone.  
2. **External Storage:** Store these assets in an S3 bucket, Google Drive, or a separate "assets" repository.  
3. **The Fetch Script:** Include a script scripts/install-assets.sh that curls these resources during setup.  
   Bash  
   \# scripts/install-assets.sh  
   curl \-L "https://myserver.com/fonts.zip" \-o /tmp/fonts.zip  
   unzip /tmp/fonts.zip \-d "$XDG\_DATA\_HOME/fonts"

This keeps the Git repository lightweight and portable.

## ---

**10\. Implementation Roadmap**

To transition from a cluttered home directory to this minimal architecture, follow this execution plan.

### **Phase 1: Preparation (The Audit)**

1. **Backup:** Perform a full backup of your current home directory.  
2. **Audit:** Run ls \-a \~ and categorize every item:  
   * **Config:** .bashrc, .gitconfig \-\> Move to .config  
   * **Data:** .ssh, .gnupg \-\> Decide on Shim strategy  
   * **Cache:** .npm, .cache \-\> Delete (they will regenerate)  
   * **Junk:** .DS\_Store, old build logs \-\> Delete

### **Phase 2: The Skeleton**

1. Create the XDG structure:  
   Bash  
   mkdir \-p \~/.config \~/.local/share \~/.local/state \~/.cache \~/.cfg

2. Initialize the Bare Repo:  
   Bash  
   git init \--bare $HOME/.cfg  
   alias config='/usr/bin/git \--git-dir=$HOME/.cfg/ \--work-tree=$HOME'  
   config config \--local status.showUntrackedFiles no

### **Phase 3: The Migration**

1. **Shell:** Create the \~/.zshenv bootstrapper (as defined in Section 4.1).  
2. **Move Configs:** Relocate application configs to \~/.config/.  
   * Move \~/.gitconfig to \~/.config/git/config. *Note: You must set export GIT\_CONFIG\_GLOBAL="$XDG\_CONFIG\_HOME/git/config" in your .zshenv for this to work.*  
3. **Shim Apps:** Add the necessary export variables for AWS, Kube, Cargo, etc., to \~/.config/zsh/.zshenv.

### **Phase 4: Persistence**

1. **Commit:** config add.zshenv.config/zsh \-\> config commit.  
2. **Push:** Push to your private GitHub repository.  
3. **Restore:** On a new machine:  
   Bash  
   git clone \--bare git@github.com:user/dotfiles.git $HOME/.cfg  
   alias config='/usr/bin/git \--git-dir=$HOME/.cfg/ \--work-tree=$HOME'  
   config checkout

   *Note: checkout will fail if files already exist (like default .bashrc). You must move/delete conflicting files before checking out.*

## **11\. Conclusion**

The "Minimal Root" is not just an aesthetic preference; it is a discipline that enforces separation of concerns between system configuration, ephemeral state, and user data. By rigorously applying the XDG Base Directory specification and utilizing a Bare Git Repository, a developer can transform their home directory from a fragile, cluttered artifact into a resilient, version-controlled infrastructure. While operating systems like macOS and legacy tools like OpenSSH resist this order, the strategic use of environment variable shims and symlinks bridges the gap, allowing for a clean, harmonious, and highly productive computing environment.

#### **Works cited**

1. XDG basedir: cleaning the clutter in my homedir \- Evy's blog \- Bongers, accessed January 29, 2026, [https://evybongers.nl/post/the-journey-to-xdg-basedir/](https://evybongers.nl/post/the-journey-to-xdg-basedir/)  
2. Exploring Tools For Managing Your Dotfiles \- GBergatto, accessed January 29, 2026, [https://gbergatto.github.io/posts/tools-managing-dotfiles/](https://gbergatto.github.io/posts/tools-managing-dotfiles/)  
3. Managing my dot files: Git bare or Stow ? : r/linuxquestions \- Reddit, accessed January 29, 2026, [https://www.reddit.com/r/linuxquestions/comments/10zrqas/managing\_my\_dot\_files\_git\_bare\_or\_stow/](https://www.reddit.com/r/linuxquestions/comments/10zrqas/managing_my_dot_files_git_bare_or_stow/)  
4. Managing my dotfiles as a git repository \- Drew DeVault's blog, accessed January 29, 2026, [https://drewdevault.com/2019/12/30/dotfiles.html](https://drewdevault.com/2019/12/30/dotfiles.html)  
5. Comparison table \- chezmoi, accessed January 29, 2026, [https://www.chezmoi.io/comparison-table/](https://www.chezmoi.io/comparison-table/)  
6. Manage machine-to-machine differences \- chezmoi, accessed January 29, 2026, [https://www.chezmoi.io/user-guide/manage-machine-to-machine-differences/](https://www.chezmoi.io/user-guide/manage-machine-to-machine-differences/)  
7. Zsh \- GitHub Gist, accessed January 29, 2026, [https://gist.github.com/fredjoseph/e81be37b8605590ef7f4cfaef1f476d2](https://gist.github.com/fredjoseph/e81be37b8605590ef7f4cfaef1f476d2)  
8. move config files away from home : r/zsh \- Reddit, accessed January 29, 2026, [https://www.reddit.com/r/zsh/comments/wycqlq/move\_config\_files\_away\_from\_home/](https://www.reddit.com/r/zsh/comments/wycqlq/move_config_files_away_from_home/)  
9. Is there a way to change the extensions folder location for Visual Studio Code?, accessed January 29, 2026, [https://stackoverflow.com/questions/40080793/is-there-a-way-to-change-the-extensions-folder-location-for-visual-studio-code](https://stackoverflow.com/questions/40080793/is-there-a-way-to-change-the-extensions-folder-location-for-visual-studio-code)  
10. How to change Extensions' location for VS Code \- Stack Overflow, accessed January 29, 2026, [https://stackoverflow.com/questions/66138496/how-to-change-extensions-location-for-vs-code](https://stackoverflow.com/questions/66138496/how-to-change-extensions-location-for-vs-code)  
11. How to Move Your Extensions Folder in VS Code \- The Renegade Coder, accessed January 29, 2026, [https://therenegadecoder.com/code/how-to-move-your-extensions-folder-in-vs-code/](https://therenegadecoder.com/code/how-to-move-your-extensions-folder-in-vs-code/)  
12. User and workspace settings \- Visual Studio Code, accessed January 29, 2026, [https://code.visualstudio.com/docs/configure/settings](https://code.visualstudio.com/docs/configure/settings)  
13. Connect to local MCP servers \- Model Context Protocol, accessed January 29, 2026, [https://modelcontextprotocol.io/docs/develop/connect-local-servers](https://modelcontextprotocol.io/docs/develop/connect-local-servers)  
14. Docs about user config directory \~/.claude appear to contradict actual CLI app behavior \#2277 \- GitHub, accessed January 29, 2026, [https://github.com/anthropics/claude-code/issues/2277](https://github.com/anthropics/claude-code/issues/2277)  
15. Claude Code: Best practices for agentic coding \- Anthropic, accessed January 29, 2026, [https://www.anthropic.com/engineering/claude-code-best-practices](https://www.anthropic.com/engineering/claude-code-best-practices)  
16. Claude Code settings \- Claude Code Docs, accessed January 29, 2026, [https://code.claude.com/docs/en/settings](https://code.claude.com/docs/en/settings)  
17. Organizing Cluster Access Using kubeconfig Files \- Kubernetes, accessed January 29, 2026, [https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/](https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/)  
18. Config \- K9s, accessed January 29, 2026, [https://k9scli.io/topics/config/](https://k9scli.io/topics/config/)  
19. Finding and changing the location of the shared config and credentials files of AWS SDKs and tools, accessed January 29, 2026, [https://docs.aws.amazon.com/sdkref/latest/guide/file-location.html](https://docs.aws.amazon.com/sdkref/latest/guide/file-location.html)  
20. The cli should respect XDG spec for config and credential file storage · Issue \#9031 \- GitHub, accessed January 29, 2026, [https://github.com/aws/aws-cli/issues/9031](https://github.com/aws/aws-cli/issues/9031)  
21. 4 secrets management tools for Git encryption | Opensource.com, accessed January 29, 2026, [https://opensource.com/article/19/2/secrets-management-tools-git](https://opensource.com/article/19/2/secrets-management-tools-git)  
22. Securely storing secrets in Git \- Medium, accessed January 29, 2026, [https://medium.com/@slimm609/securely-storing-secrets-in-git-542771d3ed8c](https://medium.com/@slimm609/securely-storing-secrets-in-git-542771d3ed8c)  
23. XDG user directories \- ArchWiki, accessed January 29, 2026, [https://wiki.archlinux.org/title/XDG\_user\_directories](https://wiki.archlinux.org/title/XDG_user_directories)  
24. GitHub Storage Limits \- Blog \- GitProtect.io, accessed January 29, 2026, [https://gitprotect.io/blog/github-storage-limits/](https://gitprotect.io/blog/github-storage-limits/)  
25. About Git Large File Storage \- GitHub Docs, accessed January 29, 2026, [https://docs.github.com/repositories/working-with-files/managing-large-files/about-git-large-file-storage](https://docs.github.com/repositories/working-with-files/managing-large-files/about-git-large-file-storage)